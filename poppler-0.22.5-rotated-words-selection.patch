--- poppler-0.22.5/poppler/TextOutputDev.cc
+++ poppler-0.22.5/poppler/TextOutputDev.cc
@@ -171,6 +171,12 @@
 // Max distance between edge of text and edge of link border
 #define hyperlinkSlack 2
 
+// Returns whether x is between a and b or equal to a or b.
+// a and b don't need to be sorted.
+#define XBetweenAB(x,a,b) (!(((x) > (a) && (x) > (b)) || \
+                             ((x) < (a) && (x) < (b))) ? \
+                           gTrue : gFalse)
+
 //------------------------------------------------------------------------
 // TextUnderline
 //------------------------------------------------------------------------
@@ -4220,11 +4226,37 @@ void TextSelectionSizer::visitLine (Text
   PDFRectangle *rect;
   double x1, y1, x2, y2, margin;
 
-  margin = (line->yMax - line->yMin) / 8;
-  x1 = line->edge[edge_begin];
-  y1 = line->yMin - margin;
-  x2 = line->edge[edge_end];
-  y2 = line->yMax + margin;
+  switch (line->rot) {
+  default:
+  case 0:
+    margin = (line->yMax - line->yMin) / 8;
+    x1 = line->edge[edge_begin];
+    x2 = line->edge[edge_end];
+    y1 = line->yMin - margin;
+    y2 = line->yMax + margin;
+    break;
+  case 1:
+    margin = (line->xMax - line->xMin) / 8;
+    x1 = line->xMin - margin;
+    x2 = line->xMax + margin;
+    y1 = line->edge[edge_begin];
+    y2 = line->edge[edge_end];
+    break;
+  case 2:
+    margin = (line->yMax - line->yMin) / 8;
+    x1 = line->edge[edge_end];
+    x2 = line->edge[edge_begin];
+    y1 = line->yMin - margin;
+    y2 = line->yMax + margin;
+    break;
+  case 3:
+    margin = (line->xMax - line->xMin) / 8;
+    x1 = line->xMin - margin;
+    x2 = line->xMax + margin;
+    y1 = line->edge[edge_end];
+    y2 = line->edge[edge_begin];
+    break;
+  }
 
   rect = new PDFRectangle (floor (x1 * scale), 
 			   floor (y1 * scale),
@@ -4304,22 +4336,59 @@ void TextSelectionPainter::visitLine (Te
   state->setFillColor(box_color);
   out->updateFillColor(state);
 
-  margin = (line->yMax - line->yMin) / 8;
-  x1 = floor (line->edge[edge_begin]);
-  y1 = floor (line->yMin - margin);
-  x2 = ceil (line->edge[edge_end]);
-  y2 = ceil (line->yMax + margin);
-
   state->getCTM (&ctm);
-  ctm.transform(line->edge[edge_begin], line->yMin - margin, &x1, &y1);
-  ctm.transform(line->edge[edge_end], line->yMax + margin, &x2, &y2);
+  ctm.invertTo (&ictm);
 
-  x1 = floor (x1);
-  y1 = floor (y1);
-  x2 = ceil (x2);
-  y2 = ceil (y2);
+  switch (line->rot) {
+  case 0:
+    margin = (line->yMax - line->yMin) / 8;
+    x1 = line->edge[edge_begin];
+    x2 = line->edge[edge_end];
+    y1 = line->yMin - margin;
+    y2 = line->yMax + margin;
+    break;
+  case 1:
+    margin = (line->xMax - line->xMin) / 8;
+    x1 = line->xMin - margin;
+    x2 = line->xMax + margin;
+    y1 = line->edge[edge_begin];
+    y2 = line->edge[edge_end];
+    break;
+  case 2:
+    margin = (line->yMax - line->yMin) / 8;
+    x1 = line->edge[edge_end];
+    x2 = line->edge[edge_begin];
+    y1 = line->yMin - margin;
+    y2 = line->yMax + margin;
+    break;
+  case 3:
+    margin = (line->xMax - line->xMin) / 8;
+    x1 = line->xMin - margin;
+    x2 = line->xMax + margin;
+    y1 = line->edge[edge_end];
+    y2 = line->edge[edge_begin];
+    break;
+  }
+
+  ctm.transform(x1, y1, &x1, &y1);
+  ctm.transform(x2, y2, &x2, &y2);
+
+  if (x1 < x2) {
+    x1 = floor (x1);
+    x2 = ceil (x2);
+  } else {
+    x1 = ceil (x1);
+    x2 = floor (x2);
+  }
+
+  if (y1 < y2) {
+    y1 = floor (y1);
+    y2 = ceil (y2);
+  } else {
+    y1 = ceil (y1);
+    y2 = floor (y2);
+  }
 
-  ctm.invertTo (&ictm);
   ictm.transform(x1, y1, &x1, &y1);
   ictm.transform(x2, y2, &x2, &y2);
 
@@ -4376,17 +4445,27 @@ void TextWord::visitSelection(TextSelect
 			      SelectionStyle style)
 {
   int i, begin, end;
-  double mid;
+  double mid, s1, s2;
+
+  if (rot == 0 || rot == 2) {
+    s1 = selection->x1;
+    s2 = selection->x2;
+  } else {
+    s1 = selection->y1;
+    s2 = selection->y2;
+  }
 
   begin = len;
   end = 0;
   for (i = 0; i < len; i++) {
     mid = (edge[i] + edge[i + 1]) / 2;
-    if (selection->x1 < mid || selection->x2 < mid)
-      if (i < begin)
-	begin = i;
-    if (mid < selection->x1 || mid < selection->x2)
-      end = i + 1;
+    if (XBetweenAB (mid, s1, s2))
+      {
+        if (i < begin)
+          begin = i;
+
+        end = i + 1;
+      }
   }
 
   /* Skip empty selection. */
@@ -4402,30 +4481,41 @@ void TextLine::visitSelection(TextSelect
   TextWord *p, *begin, *end, *current;
   int i, edge_begin, edge_end;
   PDFRectangle child_selection;
+  double s1, s2, p_min, p_max;
+
+  if (rot == 0 || rot == 2) {
+    s1 = selection->x1;
+    s2 = selection->x2;
+  } else {
+    s1 = selection->y1;
+    s2 = selection->y2;
+  }
 
   begin = NULL;
   end = NULL;
   current = NULL;
   for (p = words; p != NULL; p = p->next) {
+    if (rot == 0 || rot == 2) {
+      p_min = p->xMin;
+      p_max = p->xMax;
+    } else {
+      p_min = p->yMin;
+      p_max = p->yMax;
+    }
+
     if (blk->page->primaryLR) {
-      if ((selection->x1 < p->xMax) ||
-	  (selection->x2 < p->xMax))
-        if (begin == NULL) 
-	  begin = p;
+      if (((s1 < p_max) || (s2 < p_max)) && begin == NULL)
+        begin = p;
 
-      if (((selection->x1 > p->xMin) ||
-	   (selection->x2 > p->xMin)) && (begin != NULL)) {
+      if (((s1 > p_min) || (s2 > p_min)) && begin != NULL) {
         end = p->next;
         current = p;
       }
     } else {
-      if ((selection->x1 > p->xMin) ||
-	  (selection->x2 > p->xMin))
-        if (begin == NULL) 
-	  begin = p;
+      if (((s1 > p_min) || (s2 > p_min)) && begin == NULL)
+        begin = p;
 
-      if (((selection->x1 < p->xMax) ||
-	   (selection->x2 < p->xMax)) && (begin != NULL)) {
+      if (((s1 < p_max) || (s2 < p_max)) && begin != NULL) {
         end = p->next;
         current = p;
       }
@@ -4437,23 +4527,42 @@ void TextLine::visitSelection(TextSelect
   
   child_selection = *selection;
   if (style == selectionStyleWord) {
-    child_selection.x1 = begin ? begin->xMin : xMin;
-    if (end && end->xMax != -1) {
-      child_selection.x2 = current->xMax;
+    if (rot == 0 || rot == 2) {
+      child_selection.x1 = begin ? begin->xMin : xMin;
+      if (end && end->xMax != -1) {
+        child_selection.x2 = current->xMax;
+      } else {
+        child_selection.x2 = xMax;
+      }
     } else {
-      child_selection.x2 = xMax;
+      child_selection.y1 = begin ? begin->yMin : yMin;
+      if (end && end->yMax != -1) {
+        child_selection.y2 = current->yMax;
+      } else {
+        child_selection.y2 = yMax;
+      }
     }
   }
 
+  if (rot == 0 || rot == 2) {
+    s1 = child_selection.x1;
+    s2 = child_selection.x2;
+  } else {
+    s1 = child_selection.y1;
+    s2 = child_selection.y2;
+  }
+
   edge_begin = len;
   edge_end = 0;
   for (i = 0; i < len; i++) {
     double mid = (edge[i] + edge[i + 1]) /  2;
-    if (child_selection.x1 < mid || child_selection.x2 < mid)
-      if (i < edge_begin)
-	edge_begin = i;
-    if (mid < child_selection.x2 || mid < child_selection.x1)
-      edge_end = i + 1;
+    if (XBetweenAB (mid, s1, s2))
+      {
+        if (i < edge_begin)
+          edge_begin = i;
+
+        edge_end = i + 1;
+      }
   }
 
   /* Skip empty selection. */
